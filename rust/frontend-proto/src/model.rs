// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `model.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct Position {
    // message fields
    pub x: f32,
    pub y: f32,
    pub z: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Position {
    fn default() -> &'a Position {
        <Position as ::protobuf::Message>::default_instance()
    }
}

impl Position {
    pub fn new() -> Position {
        ::std::default::Default::default()
    }

    // float x = 1;


    pub fn get_x(&self) -> f32 {
        self.x
    }
    pub fn clear_x(&mut self) {
        self.x = 0.;
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = v;
    }

    // float y = 2;


    pub fn get_y(&self) -> f32 {
        self.y
    }
    pub fn clear_y(&mut self) {
        self.y = 0.;
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = v;
    }

    // float z = 3;


    pub fn get_z(&self) -> f32 {
        self.z
    }
    pub fn clear_z(&mut self) {
        self.z = 0.;
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f32) {
        self.z = v;
    }
}

impl ::protobuf::Message for Position {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.z = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.x != 0. {
            my_size += 5;
        }
        if self.y != 0. {
            my_size += 5;
        }
        if self.z != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.x != 0. {
            os.write_float(1, self.x)?;
        }
        if self.y != 0. {
            os.write_float(2, self.y)?;
        }
        if self.z != 0. {
            os.write_float(3, self.z)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Position {
        Position::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "x",
                |m: &Position| { &m.x },
                |m: &mut Position| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "y",
                |m: &Position| { &m.y },
                |m: &mut Position| { &mut m.y },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "z",
                |m: &Position| { &m.z },
                |m: &mut Position| { &mut m.z },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Position>(
                "Position",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Position {
        static instance: ::protobuf::rt::LazyV2<Position> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Position::new)
    }
}

impl ::protobuf::Clear for Position {
    fn clear(&mut self) {
        self.x = 0.;
        self.y = 0.;
        self.z = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Position {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Position {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Orientation {
    // message fields
    pub yaw: f32,
    pub pitch: f32,
    pub roll: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Orientation {
    fn default() -> &'a Orientation {
        <Orientation as ::protobuf::Message>::default_instance()
    }
}

impl Orientation {
    pub fn new() -> Orientation {
        ::std::default::Default::default()
    }

    // float yaw = 1;


    pub fn get_yaw(&self) -> f32 {
        self.yaw
    }
    pub fn clear_yaw(&mut self) {
        self.yaw = 0.;
    }

    // Param is passed by value, moved
    pub fn set_yaw(&mut self, v: f32) {
        self.yaw = v;
    }

    // float pitch = 2;


    pub fn get_pitch(&self) -> f32 {
        self.pitch
    }
    pub fn clear_pitch(&mut self) {
        self.pitch = 0.;
    }

    // Param is passed by value, moved
    pub fn set_pitch(&mut self, v: f32) {
        self.pitch = v;
    }

    // float roll = 3;


    pub fn get_roll(&self) -> f32 {
        self.roll
    }
    pub fn clear_roll(&mut self) {
        self.roll = 0.;
    }

    // Param is passed by value, moved
    pub fn set_roll(&mut self, v: f32) {
        self.roll = v;
    }
}

impl ::protobuf::Message for Orientation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.yaw = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pitch = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.roll = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.yaw != 0. {
            my_size += 5;
        }
        if self.pitch != 0. {
            my_size += 5;
        }
        if self.roll != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.yaw != 0. {
            os.write_float(1, self.yaw)?;
        }
        if self.pitch != 0. {
            os.write_float(2, self.pitch)?;
        }
        if self.roll != 0. {
            os.write_float(3, self.roll)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Orientation {
        Orientation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "yaw",
                |m: &Orientation| { &m.yaw },
                |m: &mut Orientation| { &mut m.yaw },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "pitch",
                |m: &Orientation| { &m.pitch },
                |m: &mut Orientation| { &mut m.pitch },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "roll",
                |m: &Orientation| { &m.roll },
                |m: &mut Orientation| { &mut m.roll },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Orientation>(
                "Orientation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Orientation {
        static instance: ::protobuf::rt::LazyV2<Orientation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Orientation::new)
    }
}

impl ::protobuf::Clear for Orientation {
    fn clear(&mut self) {
        self.yaw = 0.;
        self.pitch = 0.;
        self.roll = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Orientation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Orientation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Chip {
    // message fields
    pub kind: super::common::ChipKind,
    pub id: i32,
    pub name: ::std::string::String,
    pub manufacturer: ::std::string::String,
    pub product_name: ::std::string::String,
    pub capture: State,
    // message oneof groups
    pub chip: ::std::option::Option<Chip_oneof_chip>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Chip {
    fn default() -> &'a Chip {
        <Chip as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Chip_oneof_chip {
    bt(Chip_Bluetooth),
    uwb(Chip_Radio),
    wifi(Chip_Radio),
}

impl Chip {
    pub fn new() -> Chip {
        ::std::default::Default::default()
    }

    // .netsim.common.ChipKind kind = 1;


    pub fn get_kind(&self) -> super::common::ChipKind {
        self.kind
    }
    pub fn clear_kind(&mut self) {
        self.kind = super::common::ChipKind::UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: super::common::ChipKind) {
        self.kind = v;
    }

    // int32 id = 2;


    pub fn get_id(&self) -> i32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string manufacturer = 4;


    pub fn get_manufacturer(&self) -> &str {
        &self.manufacturer
    }
    pub fn clear_manufacturer(&mut self) {
        self.manufacturer.clear();
    }

    // Param is passed by value, moved
    pub fn set_manufacturer(&mut self, v: ::std::string::String) {
        self.manufacturer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_manufacturer(&mut self) -> &mut ::std::string::String {
        &mut self.manufacturer
    }

    // Take field
    pub fn take_manufacturer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.manufacturer, ::std::string::String::new())
    }

    // string product_name = 5;


    pub fn get_product_name(&self) -> &str {
        &self.product_name
    }
    pub fn clear_product_name(&mut self) {
        self.product_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_product_name(&mut self, v: ::std::string::String) {
        self.product_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product_name(&mut self) -> &mut ::std::string::String {
        &mut self.product_name
    }

    // Take field
    pub fn take_product_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.product_name, ::std::string::String::new())
    }

    // .netsim.model.State capture = 6;


    pub fn get_capture(&self) -> State {
        self.capture
    }
    pub fn clear_capture(&mut self) {
        self.capture = State::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_capture(&mut self, v: State) {
        self.capture = v;
    }

    // .netsim.model.Chip.Bluetooth bt = 7;


    pub fn get_bt(&self) -> &Chip_Bluetooth {
        match self.chip {
            ::std::option::Option::Some(Chip_oneof_chip::bt(ref v)) => v,
            _ => <Chip_Bluetooth as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_bt(&mut self) {
        self.chip = ::std::option::Option::None;
    }

    pub fn has_bt(&self) -> bool {
        match self.chip {
            ::std::option::Option::Some(Chip_oneof_chip::bt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bt(&mut self, v: Chip_Bluetooth) {
        self.chip = ::std::option::Option::Some(Chip_oneof_chip::bt(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bt(&mut self) -> &mut Chip_Bluetooth {
        if let ::std::option::Option::Some(Chip_oneof_chip::bt(_)) = self.chip {
        } else {
            self.chip = ::std::option::Option::Some(Chip_oneof_chip::bt(Chip_Bluetooth::new()));
        }
        match self.chip {
            ::std::option::Option::Some(Chip_oneof_chip::bt(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bt(&mut self) -> Chip_Bluetooth {
        if self.has_bt() {
            match self.chip.take() {
                ::std::option::Option::Some(Chip_oneof_chip::bt(v)) => v,
                _ => panic!(),
            }
        } else {
            Chip_Bluetooth::new()
        }
    }

    // .netsim.model.Chip.Radio uwb = 8;


    pub fn get_uwb(&self) -> &Chip_Radio {
        match self.chip {
            ::std::option::Option::Some(Chip_oneof_chip::uwb(ref v)) => v,
            _ => <Chip_Radio as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_uwb(&mut self) {
        self.chip = ::std::option::Option::None;
    }

    pub fn has_uwb(&self) -> bool {
        match self.chip {
            ::std::option::Option::Some(Chip_oneof_chip::uwb(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uwb(&mut self, v: Chip_Radio) {
        self.chip = ::std::option::Option::Some(Chip_oneof_chip::uwb(v))
    }

    // Mutable pointer to the field.
    pub fn mut_uwb(&mut self) -> &mut Chip_Radio {
        if let ::std::option::Option::Some(Chip_oneof_chip::uwb(_)) = self.chip {
        } else {
            self.chip = ::std::option::Option::Some(Chip_oneof_chip::uwb(Chip_Radio::new()));
        }
        match self.chip {
            ::std::option::Option::Some(Chip_oneof_chip::uwb(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_uwb(&mut self) -> Chip_Radio {
        if self.has_uwb() {
            match self.chip.take() {
                ::std::option::Option::Some(Chip_oneof_chip::uwb(v)) => v,
                _ => panic!(),
            }
        } else {
            Chip_Radio::new()
        }
    }

    // .netsim.model.Chip.Radio wifi = 9;


    pub fn get_wifi(&self) -> &Chip_Radio {
        match self.chip {
            ::std::option::Option::Some(Chip_oneof_chip::wifi(ref v)) => v,
            _ => <Chip_Radio as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_wifi(&mut self) {
        self.chip = ::std::option::Option::None;
    }

    pub fn has_wifi(&self) -> bool {
        match self.chip {
            ::std::option::Option::Some(Chip_oneof_chip::wifi(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_wifi(&mut self, v: Chip_Radio) {
        self.chip = ::std::option::Option::Some(Chip_oneof_chip::wifi(v))
    }

    // Mutable pointer to the field.
    pub fn mut_wifi(&mut self) -> &mut Chip_Radio {
        if let ::std::option::Option::Some(Chip_oneof_chip::wifi(_)) = self.chip {
        } else {
            self.chip = ::std::option::Option::Some(Chip_oneof_chip::wifi(Chip_Radio::new()));
        }
        match self.chip {
            ::std::option::Option::Some(Chip_oneof_chip::wifi(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_wifi(&mut self) -> Chip_Radio {
        if self.has_wifi() {
            match self.chip.take() {
                ::std::option::Option::Some(Chip_oneof_chip::wifi(v)) => v,
                _ => panic!(),
            }
        } else {
            Chip_Radio::new()
        }
    }
}

impl ::protobuf::Message for Chip {
    fn is_initialized(&self) -> bool {
        if let Some(Chip_oneof_chip::bt(ref v)) = self.chip {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Chip_oneof_chip::uwb(ref v)) = self.chip {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Chip_oneof_chip::wifi(ref v)) = self.chip {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.kind, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.manufacturer)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.product_name)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.capture, 6, &mut self.unknown_fields)?
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.chip = ::std::option::Option::Some(Chip_oneof_chip::bt(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.chip = ::std::option::Option::Some(Chip_oneof_chip::uwb(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.chip = ::std::option::Option::Some(Chip_oneof_chip::wifi(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.kind != super::common::ChipKind::UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.kind);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.manufacturer.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.manufacturer);
        }
        if !self.product_name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.product_name);
        }
        if self.capture != State::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(6, self.capture);
        }
        if let ::std::option::Option::Some(ref v) = self.chip {
            match v {
                &Chip_oneof_chip::bt(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Chip_oneof_chip::uwb(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Chip_oneof_chip::wifi(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.kind != super::common::ChipKind::UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.kind))?;
        }
        if self.id != 0 {
            os.write_int32(2, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.manufacturer.is_empty() {
            os.write_string(4, &self.manufacturer)?;
        }
        if !self.product_name.is_empty() {
            os.write_string(5, &self.product_name)?;
        }
        if self.capture != State::UNKNOWN {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.capture))?;
        }
        if let ::std::option::Option::Some(ref v) = self.chip {
            match v {
                &Chip_oneof_chip::bt(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Chip_oneof_chip::uwb(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Chip_oneof_chip::wifi(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Chip {
        Chip::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::common::ChipKind>>(
                "kind",
                |m: &Chip| { &m.kind },
                |m: &mut Chip| { &mut m.kind },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &Chip| { &m.id },
                |m: &mut Chip| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Chip| { &m.name },
                |m: &mut Chip| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "manufacturer",
                |m: &Chip| { &m.manufacturer },
                |m: &mut Chip| { &mut m.manufacturer },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "product_name",
                |m: &Chip| { &m.product_name },
                |m: &mut Chip| { &mut m.product_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<State>>(
                "capture",
                |m: &Chip| { &m.capture },
                |m: &mut Chip| { &mut m.capture },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Chip_Bluetooth>(
                "bt",
                Chip::has_bt,
                Chip::get_bt,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Chip_Radio>(
                "uwb",
                Chip::has_uwb,
                Chip::get_uwb,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Chip_Radio>(
                "wifi",
                Chip::has_wifi,
                Chip::get_wifi,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Chip>(
                "Chip",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Chip {
        static instance: ::protobuf::rt::LazyV2<Chip> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Chip::new)
    }
}

impl ::protobuf::Clear for Chip {
    fn clear(&mut self) {
        self.kind = super::common::ChipKind::UNSPECIFIED;
        self.id = 0;
        self.name.clear();
        self.manufacturer.clear();
        self.product_name.clear();
        self.capture = State::UNKNOWN;
        self.chip = ::std::option::Option::None;
        self.chip = ::std::option::Option::None;
        self.chip = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Chip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Chip {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Chip_Radio {
    // message fields
    pub state: State,
    pub range: f32,
    pub tx_count: i32,
    pub rx_count: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Chip_Radio {
    fn default() -> &'a Chip_Radio {
        <Chip_Radio as ::protobuf::Message>::default_instance()
    }
}

impl Chip_Radio {
    pub fn new() -> Chip_Radio {
        ::std::default::Default::default()
    }

    // .netsim.model.State state = 1;


    pub fn get_state(&self) -> State {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = State::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: State) {
        self.state = v;
    }

    // float range = 2;


    pub fn get_range(&self) -> f32 {
        self.range
    }
    pub fn clear_range(&mut self) {
        self.range = 0.;
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: f32) {
        self.range = v;
    }

    // int32 tx_count = 3;


    pub fn get_tx_count(&self) -> i32 {
        self.tx_count
    }
    pub fn clear_tx_count(&mut self) {
        self.tx_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_count(&mut self, v: i32) {
        self.tx_count = v;
    }

    // int32 rx_count = 4;


    pub fn get_rx_count(&self) -> i32 {
        self.rx_count
    }
    pub fn clear_rx_count(&mut self) {
        self.rx_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_count(&mut self, v: i32) {
        self.rx_count = v;
    }
}

impl ::protobuf::Message for Chip_Radio {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.range = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.tx_count = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rx_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.state != State::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.state);
        }
        if self.range != 0. {
            my_size += 5;
        }
        if self.tx_count != 0 {
            my_size += ::protobuf::rt::value_size(3, self.tx_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rx_count != 0 {
            my_size += ::protobuf::rt::value_size(4, self.rx_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.state != State::UNKNOWN {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if self.range != 0. {
            os.write_float(2, self.range)?;
        }
        if self.tx_count != 0 {
            os.write_int32(3, self.tx_count)?;
        }
        if self.rx_count != 0 {
            os.write_int32(4, self.rx_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Chip_Radio {
        Chip_Radio::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<State>>(
                "state",
                |m: &Chip_Radio| { &m.state },
                |m: &mut Chip_Radio| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "range",
                |m: &Chip_Radio| { &m.range },
                |m: &mut Chip_Radio| { &mut m.range },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tx_count",
                |m: &Chip_Radio| { &m.tx_count },
                |m: &mut Chip_Radio| { &mut m.tx_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "rx_count",
                |m: &Chip_Radio| { &m.rx_count },
                |m: &mut Chip_Radio| { &mut m.rx_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Chip_Radio>(
                "Chip.Radio",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Chip_Radio {
        static instance: ::protobuf::rt::LazyV2<Chip_Radio> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Chip_Radio::new)
    }
}

impl ::protobuf::Clear for Chip_Radio {
    fn clear(&mut self) {
        self.state = State::UNKNOWN;
        self.range = 0.;
        self.tx_count = 0;
        self.rx_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Chip_Radio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Chip_Radio {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Chip_Bluetooth {
    // message fields
    pub low_energy: ::protobuf::SingularPtrField<Chip_Radio>,
    pub classic: ::protobuf::SingularPtrField<Chip_Radio>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Chip_Bluetooth {
    fn default() -> &'a Chip_Bluetooth {
        <Chip_Bluetooth as ::protobuf::Message>::default_instance()
    }
}

impl Chip_Bluetooth {
    pub fn new() -> Chip_Bluetooth {
        ::std::default::Default::default()
    }

    // .netsim.model.Chip.Radio low_energy = 1;


    pub fn get_low_energy(&self) -> &Chip_Radio {
        self.low_energy.as_ref().unwrap_or_else(|| <Chip_Radio as ::protobuf::Message>::default_instance())
    }
    pub fn clear_low_energy(&mut self) {
        self.low_energy.clear();
    }

    pub fn has_low_energy(&self) -> bool {
        self.low_energy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_energy(&mut self, v: Chip_Radio) {
        self.low_energy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_low_energy(&mut self) -> &mut Chip_Radio {
        if self.low_energy.is_none() {
            self.low_energy.set_default();
        }
        self.low_energy.as_mut().unwrap()
    }

    // Take field
    pub fn take_low_energy(&mut self) -> Chip_Radio {
        self.low_energy.take().unwrap_or_else(|| Chip_Radio::new())
    }

    // .netsim.model.Chip.Radio classic = 2;


    pub fn get_classic(&self) -> &Chip_Radio {
        self.classic.as_ref().unwrap_or_else(|| <Chip_Radio as ::protobuf::Message>::default_instance())
    }
    pub fn clear_classic(&mut self) {
        self.classic.clear();
    }

    pub fn has_classic(&self) -> bool {
        self.classic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_classic(&mut self, v: Chip_Radio) {
        self.classic = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_classic(&mut self) -> &mut Chip_Radio {
        if self.classic.is_none() {
            self.classic.set_default();
        }
        self.classic.as_mut().unwrap()
    }

    // Take field
    pub fn take_classic(&mut self) -> Chip_Radio {
        self.classic.take().unwrap_or_else(|| Chip_Radio::new())
    }
}

impl ::protobuf::Message for Chip_Bluetooth {
    fn is_initialized(&self) -> bool {
        for v in &self.low_energy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.classic {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.low_energy)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.classic)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.low_energy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.classic.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.low_energy.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.classic.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Chip_Bluetooth {
        Chip_Bluetooth::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Chip_Radio>>(
                "low_energy",
                |m: &Chip_Bluetooth| { &m.low_energy },
                |m: &mut Chip_Bluetooth| { &mut m.low_energy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Chip_Radio>>(
                "classic",
                |m: &Chip_Bluetooth| { &m.classic },
                |m: &mut Chip_Bluetooth| { &mut m.classic },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Chip_Bluetooth>(
                "Chip.Bluetooth",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Chip_Bluetooth {
        static instance: ::protobuf::rt::LazyV2<Chip_Bluetooth> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Chip_Bluetooth::new)
    }
}

impl ::protobuf::Clear for Chip_Bluetooth {
    fn clear(&mut self) {
        self.low_energy.clear();
        self.classic.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Chip_Bluetooth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Chip_Bluetooth {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Device {
    // message fields
    pub id: i32,
    pub name: ::std::string::String,
    pub visible: bool,
    pub position: ::protobuf::SingularPtrField<Position>,
    pub orientation: ::protobuf::SingularPtrField<Orientation>,
    pub chips: ::protobuf::RepeatedField<Chip>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Device {
    fn default() -> &'a Device {
        <Device as ::protobuf::Message>::default_instance()
    }
}

impl Device {
    pub fn new() -> Device {
        ::std::default::Default::default()
    }

    // int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // bool visible = 3;


    pub fn get_visible(&self) -> bool {
        self.visible
    }
    pub fn clear_visible(&mut self) {
        self.visible = false;
    }

    // Param is passed by value, moved
    pub fn set_visible(&mut self, v: bool) {
        self.visible = v;
    }

    // .netsim.model.Position position = 4;


    pub fn get_position(&self) -> &Position {
        self.position.as_ref().unwrap_or_else(|| <Position as ::protobuf::Message>::default_instance())
    }
    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: Position) {
        self.position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position(&mut self) -> &mut Position {
        if self.position.is_none() {
            self.position.set_default();
        }
        self.position.as_mut().unwrap()
    }

    // Take field
    pub fn take_position(&mut self) -> Position {
        self.position.take().unwrap_or_else(|| Position::new())
    }

    // .netsim.model.Orientation orientation = 5;


    pub fn get_orientation(&self) -> &Orientation {
        self.orientation.as_ref().unwrap_or_else(|| <Orientation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_orientation(&mut self) {
        self.orientation.clear();
    }

    pub fn has_orientation(&self) -> bool {
        self.orientation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orientation(&mut self, v: Orientation) {
        self.orientation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orientation(&mut self) -> &mut Orientation {
        if self.orientation.is_none() {
            self.orientation.set_default();
        }
        self.orientation.as_mut().unwrap()
    }

    // Take field
    pub fn take_orientation(&mut self) -> Orientation {
        self.orientation.take().unwrap_or_else(|| Orientation::new())
    }

    // repeated .netsim.model.Chip chips = 6;


    pub fn get_chips(&self) -> &[Chip] {
        &self.chips
    }
    pub fn clear_chips(&mut self) {
        self.chips.clear();
    }

    // Param is passed by value, moved
    pub fn set_chips(&mut self, v: ::protobuf::RepeatedField<Chip>) {
        self.chips = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chips(&mut self) -> &mut ::protobuf::RepeatedField<Chip> {
        &mut self.chips
    }

    // Take field
    pub fn take_chips(&mut self) -> ::protobuf::RepeatedField<Chip> {
        ::std::mem::replace(&mut self.chips, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Device {
    fn is_initialized(&self) -> bool {
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.orientation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.chips {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.visible = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.orientation)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chips)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.visible != false {
            my_size += 2;
        }
        if let Some(ref v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.orientation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.chips {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.visible != false {
            os.write_bool(3, self.visible)?;
        }
        if let Some(ref v) = self.position.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.orientation.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.chips {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Device {
        Device::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &Device| { &m.id },
                |m: &mut Device| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Device| { &m.name },
                |m: &mut Device| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "visible",
                |m: &Device| { &m.visible },
                |m: &mut Device| { &mut m.visible },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Position>>(
                "position",
                |m: &Device| { &m.position },
                |m: &mut Device| { &mut m.position },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Orientation>>(
                "orientation",
                |m: &Device| { &m.orientation },
                |m: &mut Device| { &mut m.orientation },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Chip>>(
                "chips",
                |m: &Device| { &m.chips },
                |m: &mut Device| { &mut m.chips },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Device>(
                "Device",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Device {
        static instance: ::protobuf::rt::LazyV2<Device> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Device::new)
    }
}

impl ::protobuf::Clear for Device {
    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.visible = false;
        self.position.clear();
        self.orientation.clear();
        self.chips.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Device {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Device {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Scene {
    // message fields
    pub devices: ::protobuf::RepeatedField<Device>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Scene {
    fn default() -> &'a Scene {
        <Scene as ::protobuf::Message>::default_instance()
    }
}

impl Scene {
    pub fn new() -> Scene {
        ::std::default::Default::default()
    }

    // repeated .netsim.model.Device devices = 1;


    pub fn get_devices(&self) -> &[Device] {
        &self.devices
    }
    pub fn clear_devices(&mut self) {
        self.devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_devices(&mut self, v: ::protobuf::RepeatedField<Device>) {
        self.devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_devices(&mut self) -> &mut ::protobuf::RepeatedField<Device> {
        &mut self.devices
    }

    // Take field
    pub fn take_devices(&mut self) -> ::protobuf::RepeatedField<Device> {
        ::std::mem::replace(&mut self.devices, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Scene {
    fn is_initialized(&self) -> bool {
        for v in &self.devices {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.devices)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.devices {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Scene {
        Scene::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Device>>(
                "devices",
                |m: &Scene| { &m.devices },
                |m: &mut Scene| { &mut m.devices },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Scene>(
                "Scene",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Scene {
        static instance: ::protobuf::rt::LazyV2<Scene> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Scene::new)
    }
}

impl ::protobuf::Clear for Scene {
    fn clear(&mut self) {
        self.devices.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Scene {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Scene {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Pcap {
    // message fields
    pub id: i32,
    pub chip_kind: super::common::ChipKind,
    pub chip_id: i32,
    pub device_name: ::std::string::String,
    pub state: State,
    pub size: i32,
    pub records: i32,
    pub timestamp: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pcap {
    fn default() -> &'a Pcap {
        <Pcap as ::protobuf::Message>::default_instance()
    }
}

impl Pcap {
    pub fn new() -> Pcap {
        ::std::default::Default::default()
    }

    // int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    // .netsim.common.ChipKind chip_kind = 2;


    pub fn get_chip_kind(&self) -> super::common::ChipKind {
        self.chip_kind
    }
    pub fn clear_chip_kind(&mut self) {
        self.chip_kind = super::common::ChipKind::UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_chip_kind(&mut self, v: super::common::ChipKind) {
        self.chip_kind = v;
    }

    // int32 chip_id = 3;


    pub fn get_chip_id(&self) -> i32 {
        self.chip_id
    }
    pub fn clear_chip_id(&mut self) {
        self.chip_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chip_id(&mut self, v: i32) {
        self.chip_id = v;
    }

    // string device_name = 4;


    pub fn get_device_name(&self) -> &str {
        &self.device_name
    }
    pub fn clear_device_name(&mut self) {
        self.device_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_name(&mut self, v: ::std::string::String) {
        self.device_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_name(&mut self) -> &mut ::std::string::String {
        &mut self.device_name
    }

    // Take field
    pub fn take_device_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_name, ::std::string::String::new())
    }

    // .netsim.model.State state = 5;


    pub fn get_state(&self) -> State {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = State::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: State) {
        self.state = v;
    }

    // int32 size = 6;


    pub fn get_size(&self) -> i32 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i32) {
        self.size = v;
    }

    // int32 records = 7;


    pub fn get_records(&self) -> i32 {
        self.records
    }
    pub fn clear_records(&mut self) {
        self.records = 0;
    }

    // Param is passed by value, moved
    pub fn set_records(&mut self, v: i32) {
        self.records = v;
    }

    // int32 timestamp = 8;


    pub fn get_timestamp(&self) -> i32 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i32) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for Pcap {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.chip_kind, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.chip_id = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_name)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.size = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.records = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.chip_kind != super::common::ChipKind::UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(2, self.chip_kind);
        }
        if self.chip_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.chip_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.device_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.device_name);
        }
        if self.state != State::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(5, self.state);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(6, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.records != 0 {
            my_size += ::protobuf::rt::value_size(7, self.records, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(8, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.chip_kind != super::common::ChipKind::UNSPECIFIED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.chip_kind))?;
        }
        if self.chip_id != 0 {
            os.write_int32(3, self.chip_id)?;
        }
        if !self.device_name.is_empty() {
            os.write_string(4, &self.device_name)?;
        }
        if self.state != State::UNKNOWN {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if self.size != 0 {
            os.write_int32(6, self.size)?;
        }
        if self.records != 0 {
            os.write_int32(7, self.records)?;
        }
        if self.timestamp != 0 {
            os.write_int32(8, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pcap {
        Pcap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &Pcap| { &m.id },
                |m: &mut Pcap| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::common::ChipKind>>(
                "chip_kind",
                |m: &Pcap| { &m.chip_kind },
                |m: &mut Pcap| { &mut m.chip_kind },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "chip_id",
                |m: &Pcap| { &m.chip_id },
                |m: &mut Pcap| { &mut m.chip_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_name",
                |m: &Pcap| { &m.device_name },
                |m: &mut Pcap| { &mut m.device_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<State>>(
                "state",
                |m: &Pcap| { &m.state },
                |m: &mut Pcap| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "size",
                |m: &Pcap| { &m.size },
                |m: &mut Pcap| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "records",
                |m: &Pcap| { &m.records },
                |m: &mut Pcap| { &mut m.records },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "timestamp",
                |m: &Pcap| { &m.timestamp },
                |m: &mut Pcap| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Pcap>(
                "Pcap",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Pcap {
        static instance: ::protobuf::rt::LazyV2<Pcap> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Pcap::new)
    }
}

impl ::protobuf::Clear for Pcap {
    fn clear(&mut self) {
        self.id = 0;
        self.chip_kind = super::common::ChipKind::UNSPECIFIED;
        self.chip_id = 0;
        self.device_name.clear();
        self.state = State::UNKNOWN;
        self.size = 0;
        self.records = 0;
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pcap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pcap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PhyKind {
    NONE = 0,
    BLUETOOTH_CLASSIC = 1,
    BLUETOOTH_LOW_ENERGY = 2,
    WIFI = 3,
    UWB = 4,
    WIFI_RTT = 5,
}

impl ::protobuf::ProtobufEnum for PhyKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PhyKind> {
        match value {
            0 => ::std::option::Option::Some(PhyKind::NONE),
            1 => ::std::option::Option::Some(PhyKind::BLUETOOTH_CLASSIC),
            2 => ::std::option::Option::Some(PhyKind::BLUETOOTH_LOW_ENERGY),
            3 => ::std::option::Option::Some(PhyKind::WIFI),
            4 => ::std::option::Option::Some(PhyKind::UWB),
            5 => ::std::option::Option::Some(PhyKind::WIFI_RTT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PhyKind] = &[
            PhyKind::NONE,
            PhyKind::BLUETOOTH_CLASSIC,
            PhyKind::BLUETOOTH_LOW_ENERGY,
            PhyKind::WIFI,
            PhyKind::UWB,
            PhyKind::WIFI_RTT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PhyKind>("PhyKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PhyKind {
}

impl ::std::default::Default for PhyKind {
    fn default() -> Self {
        PhyKind::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for PhyKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum State {
    UNKNOWN = 0,
    ON = 1,
    OFF = 2,
}

impl ::protobuf::ProtobufEnum for State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<State> {
        match value {
            0 => ::std::option::Option::Some(State::UNKNOWN),
            1 => ::std::option::Option::Some(State::ON),
            2 => ::std::option::Option::Some(State::OFF),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [State] = &[
            State::UNKNOWN,
            State::ON,
            State::OFF,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<State>("State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for State {
}

impl ::std::default::Default for State {
    fn default() -> Self {
        State::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bmodel.proto\x12\x0cnetsim.model\x1a\x0ccommon.proto\"4\n\x08Positi\
    on\x12\x0c\n\x01x\x18\x01\x20\x01(\x02R\x01x\x12\x0c\n\x01y\x18\x02\x20\
    \x01(\x02R\x01y\x12\x0c\n\x01z\x18\x03\x20\x01(\x02R\x01z\"I\n\x0bOrient\
    ation\x12\x10\n\x03yaw\x18\x01\x20\x01(\x02R\x03yaw\x12\x14\n\x05pitch\
    \x18\x02\x20\x01(\x02R\x05pitch\x12\x12\n\x04roll\x18\x03\x20\x01(\x02R\
    \x04roll\"\xdd\x04\n\x04Chip\x12+\n\x04kind\x18\x01\x20\x01(\x0e2\x17.ne\
    tsim.common.ChipKindR\x04kind\x12\x0e\n\x02id\x18\x02\x20\x01(\x05R\x02i\
    d\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\"\n\x0cmanufacturer\
    \x18\x04\x20\x01(\tR\x0cmanufacturer\x12!\n\x0cproduct_name\x18\x05\x20\
    \x01(\tR\x0bproductName\x12-\n\x07capture\x18\x06\x20\x01(\x0e2\x13.nets\
    im.model.StateR\x07capture\x12.\n\x02bt\x18\x07\x20\x01(\x0b2\x1c.netsim\
    .model.Chip.BluetoothH\0R\x02bt\x12,\n\x03uwb\x18\x08\x20\x01(\x0b2\x18.\
    netsim.model.Chip.RadioH\0R\x03uwb\x12.\n\x04wifi\x18\t\x20\x01(\x0b2\
    \x18.netsim.model.Chip.RadioH\0R\x04wifi\x1a~\n\x05Radio\x12)\n\x05state\
    \x18\x01\x20\x01(\x0e2\x13.netsim.model.StateR\x05state\x12\x14\n\x05ran\
    ge\x18\x02\x20\x01(\x02R\x05range\x12\x19\n\x08tx_count\x18\x03\x20\x01(\
    \x05R\x07txCount\x12\x19\n\x08rx_count\x18\x04\x20\x01(\x05R\x07rxCount\
    \x1ax\n\tBluetooth\x127\n\nlow_energy\x18\x01\x20\x01(\x0b2\x18.netsim.m\
    odel.Chip.RadioR\tlowEnergy\x122\n\x07classic\x18\x02\x20\x01(\x0b2\x18.\
    netsim.model.Chip.RadioR\x07classicB\x06\n\x04chip\"\xe1\x01\n\x06Device\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\x12\n\x04name\x18\x02\
    \x20\x01(\tR\x04name\x12\x18\n\x07visible\x18\x03\x20\x01(\x08R\x07visib\
    le\x122\n\x08position\x18\x04\x20\x01(\x0b2\x16.netsim.model.PositionR\
    \x08position\x12;\n\x0borientation\x18\x05\x20\x01(\x0b2\x19.netsim.mode\
    l.OrientationR\x0borientation\x12(\n\x05chips\x18\x06\x20\x03(\x0b2\x12.\
    netsim.model.ChipR\x05chips\"7\n\x05Scene\x12.\n\x07devices\x18\x01\x20\
    \x03(\x0b2\x14.netsim.model.DeviceR\x07devices\"\xfd\x01\n\x04Pcap\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x124\n\tchip_kind\x18\x02\x20\
    \x01(\x0e2\x17.netsim.common.ChipKindR\x08chipKind\x12\x17\n\x07chip_id\
    \x18\x03\x20\x01(\x05R\x06chipId\x12\x1f\n\x0bdevice_name\x18\x04\x20\
    \x01(\tR\ndeviceName\x12)\n\x05state\x18\x05\x20\x01(\x0e2\x13.netsim.mo\
    del.StateR\x05state\x12\x12\n\x04size\x18\x06\x20\x01(\x05R\x04size\x12\
    \x18\n\x07records\x18\x07\x20\x01(\x05R\x07records\x12\x1c\n\ttimestamp\
    \x18\x08\x20\x01(\x05R\ttimestamp*e\n\x07PhyKind\x12\x08\n\x04NONE\x10\0\
    \x12\x15\n\x11BLUETOOTH_CLASSIC\x10\x01\x12\x18\n\x14BLUETOOTH_LOW_ENERG\
    Y\x10\x02\x12\x08\n\x04WIFI\x10\x03\x12\x07\n\x03UWB\x10\x04\x12\x0c\n\
    \x08WIFI_RTT\x10\x05*%\n\x05State\x12\x0b\n\x07UNKNOWN\x10\0\x12\x06\n\
    \x02ON\x10\x01\x12\x07\n\x03OFF\x10\x02b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
