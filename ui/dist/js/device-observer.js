const i="http://localhost:7681/v1/devices";class e{constructor(i){this.device=i}get deviceSerial(){return this.device.deviceSerial}get name(){var i;return null!==(i=this.device.name)&&void 0!==i?i:""}set name(i){this.device.name=i}get position(){const i={x:0,y:0,z:0};return"position"in this.device&&this.device.position&&"object"==typeof this.device.position&&("x"in this.device.position&&"number"==typeof this.device.position.x&&(i.x=this.device.position.x),"y"in this.device.position&&"number"==typeof this.device.position.y&&(i.y=this.device.position.y),"z"in this.device.position&&"number"==typeof this.device.position.z&&(i.z=this.device.position.z)),i}set position(i){this.device.position=i}get orientation(){const i={yaw:0,pitch:0,roll:0};return"orientation"in this.device&&this.device.orientation&&"object"==typeof this.device.orientation&&("yaw"in this.device.orientation&&"number"==typeof this.device.orientation.yaw&&(i.yaw=this.device.orientation.yaw),"pitch"in this.device.orientation&&"number"==typeof this.device.orientation.pitch&&(i.pitch=this.device.orientation.pitch),"roll"in this.device.orientation&&"number"==typeof this.device.orientation.roll&&(i.roll=this.device.orientation.roll)),i}set orientation(i){this.device.orientation=i}get chips(){var i;return null!==(i=this.device.chips)&&void 0!==i?i:[]}set chips(i){this.device.chips=i}get visible(){var i;return null===(i=this.device.visible)||void 0===i||i}set visible(i){this.device.visible=i}toggleChipState(i,e){if("bt"in i&&i.bt){if(void 0===e)return void console.log("netsim-ui: must specify lowEnergy or classic for Bluetooth");"lowEnergy"===e&&"lowEnergy"in i.bt&&i.bt.lowEnergy&&"state"in i.bt.lowEnergy&&(i.bt.lowEnergy.state="ON"===i.bt.lowEnergy.state?"OFF":"ON"),"classic"===e&&"classic"in i.bt&&i.bt.classic&&"state"in i.bt.classic&&(i.bt.classic.state="ON"===i.bt.classic.state?"OFF":"ON")}"wifi"in i&&i.wifi&&"state"in i.wifi&&(i.wifi.state="ON"===i.wifi.state?"OFF":"ON"),"uwb"in i&&i.uwb&&"state"in i.uwb&&(i.uwb.state="ON"===i.uwb.state?"OFF":"ON")}toggleCapture(i,e){"capture"in e&&e.capture&&(e.capture="ON"===e.capture?"OFF":"ON",t.patchDevice({device:{deviceSerial:i.deviceSerial,chips:i.chips}}))}}const t=new class{constructor(){this.observers=[],this.simulationInfo={devices:[],selectedSerial:"",dimension:{x:10,y:10,z:0}},this.invokeGetDevice()}invokeGetDevice(){fetch(i,{method:"GET"}).then((i=>i.json())).then((i=>{this.fetchDevice(i.devices)})).catch((i=>{console.log("Cannot connect to netsim web server",i)}))}fetchDevice(i){this.simulationInfo.devices=[];for(const t of i)this.simulationInfo.devices.push(new e(t));this.notifyObservers()}patchSelected(i){this.simulationInfo.selectedSerial=i,this.notifyObservers()}handleDrop(i,e,t){for(const s of this.simulationInfo.devices)if(i===s.deviceSerial){s.position={x:e,y:t,z:s.position.z},this.patchDevice({device:{deviceSerial:i,position:s.position}});break}}patchDevice(e){const t=JSON.stringify(e);fetch(i,{method:"PATCH",headers:{"Content-Type":"application/json","Content-Length":t.length.toString()},body:t}).then((i=>i.json())).catch((i=>{console.error("Error:",i)})),this.notifyObservers()}registerObserver(i){this.observers.push(i),i.onNotify(this.simulationInfo)}removeObserver(i){const e=this.observers.indexOf(i);this.observers.splice(e,1)}notifyObservers(){for(const i of this.observers)i.onNotify(this.simulationInfo)}getDeviceList(){return this.simulationInfo.devices}};!async function(){const i=i=>new Promise((e=>setTimeout(e,i)));for(;;)t.invokeGetDevice(),await i(1e3)}();export{e as Device,t as simulationState};
